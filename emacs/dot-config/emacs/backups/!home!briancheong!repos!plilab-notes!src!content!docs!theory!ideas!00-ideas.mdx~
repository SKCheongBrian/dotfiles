---
title: Fixed-point Oriented Programming Ideas
---

# Fixed-point Oriented Programming Ideas

## Language features

### Relation operators
* e.g. Op, AddTop, AddBot, Map
* custom constructors
  * e.g. `AddTop(someRel) where top = fail Message` adds a top constructor which we refer to as `fail` and it takes a `Message` value for error reporting
  * brings up an issue: if the top carries data, then there are multiple equivalent tops, not a unique one
    * possible solution: all the elements generated by `AddTop` are mutually incomparable, thus not necessarily one unique top
    * in such case `AddMax` would be more appropriate
    * adding a top element would be a special case where exactly one new maximal element is added

### Module system
* can't exactly just piggyback off haskell's module system:
  * by default, a compiled file is largely self sufficient: it generates its own definitions of facts, database, queue, as well as the transfer function and main loop
  * because of this we cant simply generate files separately and import: we want the importing file to take into consideration the definitions that its importing
* for example, if one file defines some relations and another imports those, we want the database of the importing file to contain slots for the imported relations
=> thus we would want to do some linking

### Built-in iteration primitive
* a "for each" primitive to iterate over iterable data
* e.g. if we have `rel r: Set Nat` and `rel p: Nat, Nat`, we might wanna say `rule _: r S, s <- S |- p s s`
* this construct would put some restriction on reordering of premises!

### Pattern matching in rule assumptions

### Optimized handling of discrete variables
* if we know a variable is discrete, we dont have to check all elements to see if a fact is subsumed when inserting into the database, simply insert (insertion becomes O(log(n)) instead of O(n)

### Boolean conditions
* add an "if" construct to the syntax to enable boolean-valued guards as premises
* e.g. `rule _: r x y, if x < 5 |- ...`
* semantically, we would have to require that the condition is monotonic, otherwise we lose overall monotonicity and cant't guarantee least fixpoint (see flix paper)

### Optimized handling of discrete facts
* a fact is discrete if all of its arguments are
* their DB slot can just be a set and insertion doesn't need to check for subsumption

### Integrating with solvers
* deducing non-trivial properties of a given program for purposes of optimization of the emitted code

## Type system

### Potential typing structure
```
         'Kind'
      /    |      \
     /     |       \
 'Rel'   'Type'   'Ord'
   |       |        |
 rtype    type     ord
   |       |        |
  rel    value     leq
   |
  fact
```
* everything marked by single quotes is literal, others are syntactic categories defined as follows:
```
type  ::= T \in BaseType
value ::= num | string | cons value...
rtype ::= ()
       | rlist
rList ::= (type, leq)
          | rlist * (type, leq)
rel ::= R \in RelationSymbol
fact ::= rel value...
ord  ::= type{ ordProps... }
ordProps ::= Pos | Top | Bot | Join | Meet
leq ::= <= \in PartialOrd
```

## Syntax
* potential alternative syntax:
```
rel edge   : String, String, Dist
rel start  : String
rel distTo : String, Dist where
  init: start s |- distTo s (DistNat 0)
  addDist:  distTo v1 d1, edge v1 v2 d2 |- distTo v2 (add d1 d2)
```

# Comparisons
* flix supports only a fixed number of "cells" (see flix paper 3.2): "To ensure a finite number of cells, we restrict the terms that can appear in a ground atom. (...) Since T consists of terms that syntactically appear in the program P, it is finite and consequently the number of cells is finite."

# Unsorted
- Reduced products in static analysis
- Rete Network Algorithm (Prolog)
- Lattice of Lattices: e.g., (mod 2) vs (Mod 4) lattice
- Sub-modularity is why Dijkstra is correct
- Support multiple independant indexes
- JIT Tiers of Analysis
 - Linear Scan Register Allocator
 - Graph Allocator
